基于您的项目架构，我将提供一个完整的代理功能集成方案。您的项目结构清晰，代理功能可以优雅地融入现有架构。

## 📋 集成方案概述

### 1️⃣ **部署代理Worker**

首先，将您的 `worker.js` 部署为独立的 Cloudflare Worker：

```javascript
// 修改 worker.js，添加CORS支持和更好的错误处理
export default {
  async fetch(request, env, ctx) {
    try {
      // 添加CORS头支持您的主站访问
      const corsHeaders = {
        'Access-Control-Allow-Origin': env.ALLOWED_ORIGINS || '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type',
      };

      // 处理预检请求
      if (request.method === 'OPTIONS') {
        return new Response(null, { headers: corsHeaders });
      }

      // 现有的代理逻辑...
      const {
        PROXY_HOSTNAME,
        PROXY_PROTOCOL = "https",
        // ... 其他配置
      } = env;

      // 添加响应头
      const response = await handleProxyRequest(request, env);
      Object.entries(corsHeaders).forEach(([key, value]) => {
        response.headers.set(key, value);
      });
      
      return response;
    } catch (error) {
      console.error('Proxy error:', error);
      return new Response('Proxy Error', { status: 500 });
    }
  }
};
```

### 2️⃣ **修改搜索结果处理**

在 `frontend/src/services/search.js` 中添加代理URL包装功能：

```javascript
// 在 SearchService 类中添加代理配置
class SearchService {
  constructor() {
    // ... 现有代码
    
    // 代理配置
    this.proxyConfig = {
      enabled: false, // 通过用户设置控制
      baseUrl: '', // 代理服务器URL
      needsProxy: new Set(), // 需要代理的搜索源ID
    };
  }

  // 初始化代理配置
  async initProxyConfig() {
    try {
      // 从用户设置或环境变量获取代理配置
      const userSettings = await this.getUserSettings();
      const proxyBaseUrl = window.API_CONFIG?.PROXY_BASE_URL || 
                          'https://your-proxy.workers.dev';
      
      this.proxyConfig = {
        enabled: userSettings.enableProxy || false,
        baseUrl: proxyBaseUrl,
        // 从数据库或配置获取需要代理的源
        needsProxy: new Set(userSettings.proxiedSources || [
          'javbus', 'javdb', 'javlibrary', 'btsow'
        ])
      };
    } catch (error) {
      console.error('初始化代理配置失败:', error);
    }
  }

  // 包装URL为代理URL
  wrapWithProxy(url, sourceId) {
    // 检查是否需要代理
    if (!this.proxyConfig.enabled || !this.proxyConfig.needsProxy.has(sourceId)) {
      return url;
    }

    try {
      const targetUrl = new URL(url);
      const proxyUrl = new URL(this.proxyConfig.baseUrl);
      
      // 构建代理URL
      // 方案1: 使用路径参数
      proxyUrl.pathname = `/proxy/${targetUrl.hostname}${targetUrl.pathname}`;
      proxyUrl.search = targetUrl.search;
      
      // 方案2: 使用查询参数（备选）
      // proxyUrl.searchParams.set('target', url);
      
      return proxyUrl.toString();
    } catch (error) {
      console.error('包装代理URL失败:', error);
      return url; // 失败时返回原URL
    }
  }

  // 修改构建搜索结果方法
  buildResultsFromSources(sources, keyword, encodedKeyword, timestamp) {
    return sources.map(source => {
      const originalUrl = source.urlTemplate.replace('{keyword}', encodedKeyword);
      
      // 应用代理包装
      const proxyUrl = this.wrapWithProxy(originalUrl, source.id);
      
      const result = {
        id: `result_${keyword}_${source.id}_${timestamp}`,
        title: source.name,
        subtitle: source.subtitle,
        url: proxyUrl, // 使用代理URL
        originalUrl: originalUrl, // 保留原始URL
        source: source.id,
        keyword: keyword,
        timestamp: timestamp,
        needsProxy: this.proxyConfig.needsProxy.has(source.id)
      };
      
      // ... 其他字段
      
      return result;
    });
  }
}
```

### 3️⃣ **添加数据库支持**

在 `sqllite d1/08_search_source.sql` 中添加代理配置字段：

```sql
-- 在 search_sources 表中添加代理配置
ALTER TABLE search_sources ADD COLUMN needs_proxy INTEGER DEFAULT 0;
ALTER TABLE search_sources ADD COLUMN proxy_config TEXT DEFAULT NULL;

-- 在 user_search_source_configs 表中添加用户级代理配置
ALTER TABLE user_search_source_configs ADD COLUMN use_proxy INTEGER DEFAULT 0;
ALTER TABLE user_search_source_configs ADD COLUMN custom_proxy_url TEXT DEFAULT NULL;

-- 更新需要代理的默认搜索源
UPDATE search_sources 
SET needs_proxy = 1 
WHERE id IN ('javbus', 'javdb', 'javlibrary', 'btsow', 'sukebei');
```

### 4️⃣ **后端API支持**

在 `src/handlers/search-sources.js` 中添加代理配置处理：

```javascript
// 添加获取代理配置的处理器
export async function getProxyConfigHandler(request, env) {
  const user = await authenticate(request, env);
  if (!user) {
    return utils.errorResponse('认证失败', 401);
  }

  try {
    // 获取用户的代理配置
    const proxyConfig = await env.DB.prepare(`
      SELECT 
        ss.id,
        ss.name,
        ss.needs_proxy,
        ss.proxy_config,
        usc.use_proxy as user_proxy_enabled,
        usc.custom_proxy_url
      FROM search_sources ss
      LEFT JOIN user_search_source_configs usc 
        ON ss.id = usc.source_id AND usc.user_id = ?
      WHERE ss.needs_proxy = 1
    `).bind(user.id).all();

    // 获取全局代理设置
    const globalProxy = {
      enabled: env.PROXY_ENABLED === 'true',
      baseUrl: env.PROXY_BASE_URL || '',
      defaultSources: env.PROXY_DEFAULT_SOURCES?.split(',') || []
    };

    return utils.successResponse({
      global: globalProxy,
      sources: proxyConfig.results || []
    });
  } catch (error) {
    console.error('获取代理配置失败:', error);
    return utils.errorResponse('获取代理配置失败', 500);
  }
}

// 更新用户代理设置
export async function updateProxySettingsHandler(request, env) {
  const user = await authenticate(request, env);
  if (!user) {
    return utils.errorResponse('认证失败', 401);
  }

  try {
    const { sourceId, useProxy, customProxyUrl } = await request.json();
    
    await env.DB.prepare(`
      UPDATE user_search_source_configs 
      SET use_proxy = ?, custom_proxy_url = ?, updated_at = ?
      WHERE user_id = ? AND source_id = ?
    `).bind(
      useProxy ? 1 : 0,
      customProxyUrl || null,
      Date.now(),
      user.id,
      sourceId
    ).run();

    return utils.successResponse({ message: '代理设置已更新' });
  } catch (error) {
    console.error('更新代理设置失败:', error);
    return utils.errorResponse('更新代理设置失败', 500);
  }
}
```

### 5️⃣ **前端UI集成**

在 `SearchResultsRenderer.js` 中添加代理状态显示：

```javascript
createResultHTML(result, config) {
  // ... 现有代码
  
  // 添加代理状态指示
  const proxyIndicator = result.needsProxy ? `
    <span class="proxy-indicator" title="通过代理访问">
      🔐 代理
    </span>
  ` : '';
  
  // 修改访问按钮，支持代理和直连切换
  const visitButtonHTML = `
    <div class="visit-options">
      <button class="action-btn visit-btn" 
              data-action="visit" 
              data-url="${escapeHtml(result.url)}" 
              data-source="${result.source}">
        <span>访问${result.needsProxy ? '(代理)' : ''}</span>
      </button>
      ${result.needsProxy && result.originalUrl ? `
        <button class="action-btn direct-btn" 
                data-action="visitDirect" 
                data-url="${escapeHtml(result.originalUrl)}"
                title="直接访问(不使用代理)">
          <span>直连</span>
        </button>
      ` : ''}
    </div>
  `;
  
  // ... 继续现有代码
}
```

### 6️⃣ **用户设置页面**

在 `sources-manager.js` 中添加代理配置UI：

```javascript
renderSourceItem(source) {
  // ... 现有代码
  
  // 添加代理配置选项
  const proxyConfig = `
    <div class="source-proxy-config">
      <label>
        <input type="checkbox" 
               ${source.needsProxy ? 'checked' : ''} 
               onchange="app.getManager('sources').toggleSourceProxy('${source.id}', this.checked)">
        使用代理访问
      </label>
      ${source.needsProxy ? `
        <input type="text" 
               placeholder="自定义代理URL(可选)" 
               value="${source.customProxyUrl || ''}"
               onblur="app.getManager('sources').updateCustomProxy('${source.id}', this.value)">
      ` : ''}
    </div>
  `;
  
  // ... 继续渲染
}

// 添加代理控制方法
async toggleSourceProxy(sourceId, enabled) {
  try {
    await searchSourcesAPI.updateProxySettings({
      sourceId,
      useProxy: enabled
    });
    showToast(`已${enabled ? '启用' : '禁用'}代理`, 'success');
  } catch (error) {
    console.error('更新代理设置失败:', error);
    showToast('操作失败', 'error');
  }
}
```

### 7️⃣ **环境变量配置**

在 `wrangler.toml` 中添加代理配置：

```toml
[vars]
PROXY_ENABLED = "true"
PROXY_BASE_URL = "https://your-proxy.workers.dev"
PROXY_DEFAULT_SOURCES = "javbus,javdb,javlibrary,btsow"

# 代理Worker的配置
[env.proxy]
name = "magnet-search-proxy"
vars = { PROXY_HOSTNAME = "target-site.com" }
```

### 8️⃣ **智能路由策略**

创建智能代理路由服务：

```javascript
// src/services/proxy-router.js
export class ProxyRouter {
  constructor() {
    this.rules = new Map();
    this.cache = new Map();
  }

  // 根据源和地区自动选择是否使用代理
  shouldUseProxy(sourceId, userRegion) {
    // 缓存检查
    const cacheKey = `${sourceId}-${userRegion}`;
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    // 规则匹配
    const rules = {
      'javbus': ['CN', 'RU', 'IR'], // 这些地区需要代理
      'javdb': ['CN'],
      'sukebei': ['CN', 'KR'],
      // ... 更多规则
    };

    const needsProxy = rules[sourceId]?.includes(userRegion) || false;
    this.cache.set(cacheKey, needsProxy);
    
    return needsProxy;
  }

  // 选择最佳代理服务器
  selectBestProxy(sourceId, userRegion) {
    const proxies = {
      'US': 'https://us-proxy.workers.dev',
      'EU': 'https://eu-proxy.workers.dev',
      'ASIA': 'https://asia-proxy.workers.dev',
    };

    // 根据用户地区选择最近的代理
    if (userRegion === 'CN') return proxies.ASIA;
    if (['DE', 'FR', 'UK'].includes(userRegion)) return proxies.EU;
    return proxies.US;
  }
}
```

## 🚀 部署步骤

1. **部署代理Worker**:
```bash
cd proxy-worker
wrangler deploy
```

2. **更新数据库结构**:
```bash
wrangler d1 execute codeseek --file=./migrations/add-proxy-support.sql
```

3. **配置环境变量**:
```bash
wrangler secret put PROXY_BASE_URL
```

4. **更新前端配置**:
```javascript
window.API_CONFIG = {
  ...window.API_CONFIG,
  PROXY_BASE_URL: 'https://your-proxy.workers.dev',
  PROXY_ENABLED: true
};
```

这个方案可以让您的搜索结果通过代理访问，同时保持良好的用户体验和灵活的配置选项。需要我详细说明某个部分的实现吗？